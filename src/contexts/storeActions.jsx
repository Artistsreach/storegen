import React from 'react';
import { 
    fetchPexelsImages as utilFetchPexelsImages, 
    generateId as utilGenerateId, 
    generateAIProductDescriptions, 
    generateAIStoreContent,
    fetchPexelsVideos // Import the new video fetching utility
} from '@/lib/utils';
import { overlayLogoOnProductImage } from '@/lib/imageUtils';
import { 
    fetchShopifyStorefrontAPI, 
    GET_SHOP_METADATA_QUERY, 
    GET_PRODUCTS_QUERY,
    GET_COLLECTIONS_QUERY, // Added
    GET_LOCALIZATION_INFO_QUERY // Added
} from '@/lib/shopify';

const getRandomColor = () => ['#3B82F6', '#8B5CF6', '#EC4899', '#10B981', '#F59E0B', '#EF4444', '#6366F1', '#14B8A6', '#F97316'][Math.floor(Math.random() * 9)];
const getRandomFont = () => ['Inter', 'Roboto', 'Poppins', 'Montserrat', 'Open Sans'][Math.floor(Math.random() * 5)];
const getRandomLayout = () => ['grid', 'list'][Math.floor(Math.random() * 2)];


export const generateAIProductsData = async (type, count, storeName, storeLogoDataUrl, { fetchPexelsImages = utilFetchPexelsImages, generateId = utilGenerateId } = {}) => {
    const products = [];
    const priceRanges = { fashion: {min:20,max:200}, electronics: {min:50,max:1300}, food: {min:5,max:50}, jewelry: {min:100,max:1000}, general: {min:10,max:300} };
    const range = priceRanges[type] || priceRanges.general;
    const productNamesPool = {
      fashion: ['Classic Tee', 'Urban Jeans', 'Silk Scarf', 'Leather Boots', 'Summer Dress', 'Knit Sweater'],
      electronics: ['HD Webcam', 'Noise-Cancelling Buds', 'Smart Display', 'Gaming Pad', 'Portable Drive', 'VR Headset'],
      food: ['Artisan Bread', 'Gourmet Cheese', 'Organic Berries', 'Craft Coffee', 'Spiced Nuts', 'Dark Chocolate Bar'],
      jewelry: ['Pearl Necklace', 'Sapphire Ring', 'Gold Hoops', 'Charm Bracelet', 'Silver Cufflinks', 'Diamond Studs'],
      general: ['Utility Tool', 'Desk Organizer', 'Travel Mug', 'Yoga Mat', 'Scented Candle', 'Board Game']
    };
    const names = productNamesPool[type] || productNamesPool.general;
    const selectedNames = [...names].sort(() => 0.5 - Math.random()).slice(0, count);

    const imageQueries = selectedNames.map(name => `${type} ${name} product shot`);
    const productImages = await fetchPexelsImages(imageQueries.join(';'), count, 'square');

    for (let i = 0; i < count; i++) {
      const name = selectedNames[i];
      const pexelsImageObject = productImages[i];
      let finalProductImageUrl;

      if (pexelsImageObject && pexelsImageObject.src && pexelsImageObject.src.medium && storeLogoDataUrl) {
        try {
          console.log(`[generateAIProductsData] Overlaying logo on Pexels image: ${pexelsImageObject.src.medium}`);
          finalProductImageUrl = await overlayLogoOnProductImage(pexelsImageObject.src.medium, storeLogoDataUrl);
        } catch (e) {
          console.error(`[generateAIProductsData] Failed to overlay logo on ${pexelsImageObject.src.medium}, using original.`, e);
          finalProductImageUrl = pexelsImageObject.src.medium;
        }
      } else if (pexelsImageObject && pexelsImageObject.src && pexelsImageObject.src.medium) {
        finalProductImageUrl = pexelsImageObject.src.medium;
      } else {
        finalProductImageUrl = `https://via.placeholder.com/400x400.png?text=${encodeURIComponent(name)}`;
      }
      
      products.push({
        id: `product-ai-${generateId()}`,
        name,
        price: parseFloat((Math.random() * (range.max - range.min) + range.min).toFixed(2)),
        description: generateAIProductDescriptions(type, name),
        rating: (Math.random() * 1.5 + 3.5).toFixed(1),
        stock: Math.floor(Math.random() * 80) + 20,
        image: { 
          id: (pexelsImageObject && pexelsImageObject.id) || generateId(), 
          src: { medium: finalProductImageUrl }, 
          alt: (pexelsImageObject && pexelsImageObject.alt) || `Product image for ${name}` 
        },
        // logoUrl: storeLogoDataUrl, // No longer needed per product if image has logo
        storeName: storeName,
      });
    }
    return products;
};


export const generateStoreFromWizardData = async (wizardData, { fetchPexelsImages = utilFetchPexelsImages, generateId = utilGenerateId } = {}) => {
    const storeId = `store-wizard-${generateId()}`;
    const { productType, storeName, logoUrl, products: wizardProducts, prompt } = wizardData;

    let finalProducts = [];
    if (wizardProducts.source === 'ai') {
      // AI products are generated by generateProductWithGemini, which now handles logo inclusion.
      // item.imageUrl from wizardData.products.items should be the final image.
      finalProducts = wizardProducts.items.map(item => ({
        id: `product-ai-${generateId()}`,
        name: item.name,
        price: parseFloat(item.price), // Ensure price is a number
        description: item.description,
        image: { 
          id: generateId(), 
          src: { medium: item.imageUrl }, // item.imageUrl is from generateProductWithGemini, should have logo
          alt: item.name,
        },
        rating: (Math.random() * 1.5 + 3.5).toFixed(1),
        stock: Math.floor(Math.random() * 80) + 20,
      }));
    } else if (wizardProducts.source === 'manual') {
      // For manual products, use the provided details.
      // If imageUrl is provided (e.g., user pasted a URL), use it. Otherwise, placeholder.
      // DO NOT use Pexels for manual product images as per user feedback.
      finalProducts = wizardProducts.items.map(p => ({
        id: `product-manual-${generateId()}`,
        name: p.name,
        price: parseFloat(p.price),
        description: p.description || generateAIProductDescriptions(productType, p.name), // Fallback description
        image: {
          id: generateId(),
          src: { medium: p.imageUrl || `https://via.placeholder.com/400x400.png?text=${encodeURIComponent(p.name)}` },
          alt: p.name,
        },
        rating: (Math.random() * 1.5 + 3.5).toFixed(1),
        stock: Math.floor(Math.random() * 50) + 20,
      }));
    }
    
    const heroImages = await fetchPexelsImages(`${productType} store hero ${prompt}`, 1, 'landscape');
    const heroVideos = await fetchPexelsVideos(`${productType} store ambiance ${prompt}`, 1, 'landscape');
    const aiContent = generateAIStoreContent(productType, storeName);

    return {
      id: storeId,
      name: storeName,
      type: productType,
      description: aiContent.heroDescription,
      prompt: prompt || `A ${productType} store called ${storeName}`,
      products: finalProducts,
      hero_image: heroImages[0] || { src: { large: 'https://via.placeholder.com/1200x800.png?text=Hero+Image' }, alt: 'Placeholder Hero Image' },
      hero_video_url: heroVideos[0]?.url || null,
      hero_video_poster_url: heroVideos[0]?.image || null,
      logo_url: logoUrl || `https://via.placeholder.com/100x100.png?text=${storeName.substring(0,1)}`,
      theme: {
        primaryColor: getRandomColor(),
        secondaryColor: getRandomColor(),
        fontFamily: getRandomFont(),
        layout: getRandomLayout(),
      },
      content: aiContent,
      data_source: 'wizard',
    };
};

// Added storeLogoDataUrl parameter
export const generateStoreFromPromptData = async (prompt, { storeNameOverride = null, productTypeOverride = null, storeLogoDataUrl = null, fetchPexelsImages = utilFetchPexelsImages, generateId = utilGenerateId } = {}) => {
    const storeId = `store-ai-${generateId()}`;
    const keywords = prompt.toLowerCase().split(' ');
    
    let storeType = productTypeOverride || 'general';
    if (!productTypeOverride) {
      if (keywords.some(word => ['clothing', 'fashion', 'apparel', 'wear'].includes(word))) storeType = 'fashion';
      else if (keywords.some(word => ['tech', 'electronics', 'gadget', 'digital'].includes(word))) storeType = 'electronics';
      else if (keywords.some(word => ['food', 'grocery', 'meal', 'organic'].includes(word))) storeType = 'food';
      else if (keywords.some(word => ['jewelry', 'accessory', 'watch', 'luxury'].includes(word))) storeType = 'jewelry';
    }
    
    const brandWords = prompt.split(' ').filter(word => word.charAt(0) === word.charAt(0).toUpperCase() && word.length > 2);
    const brandName = storeNameOverride || brandWords[0] || `${storeType.charAt(0).toUpperCase() + storeType.slice(1)} Store ${Math.floor(Math.random() * 100)}`;
    
    // Pass storeLogoDataUrl to generateAIProductsData
    const products = await generateAIProductsData(storeType, 6, brandName, storeLogoDataUrl, { fetchPexelsImages, generateId });
    const heroImages = await fetchPexelsImages(`${storeType} ${brandName} hero ${prompt}`, 1, 'landscape');
    const heroVideos = await fetchPexelsVideos(`${storeType} ${brandName} ambiance ${prompt}`, 1, 'landscape');
    const aiContent = generateAIStoreContent(storeType, brandName);
    
    return {
      id: storeId,
      name: brandName,
      type: storeType,
      description: aiContent.heroDescription,
      prompt,
      products,
      hero_image: heroImages[0] || { src: { large: 'https://via.placeholder.com/1200x800.png?text=Hero+Image' }, alt: 'Placeholder Hero Image' },
      hero_video_url: heroVideos[0]?.url || null,
      hero_video_poster_url: heroVideos[0]?.image || null,
      logo_url: storeLogoDataUrl || `https://via.placeholder.com/100x100.png?text=${brandName.substring(0,1)}`, // Use actual logo if available
      theme: {
        primaryColor: getRandomColor(),
        secondaryColor: getRandomColor(),
        fontFamily: getRandomFont(),
        layout: getRandomLayout(),
      },
      content: aiContent,
      data_source: 'ai',
    };
};

// New function to fetch only shop metadata for preview
export const fetchShopifyStoreMetadata = async (domain, token) => {
    const shopData = await fetchShopifyStorefrontAPI(domain, token, GET_SHOP_METADATA_QUERY);
    return shopData.shop; // Return raw shop data
};

// New function to fetch collections for preview (with pagination support)
export const fetchShopifyCollectionsList = async (domain, token, first = 10, cursor = null) => {
    const collectionsData = await fetchShopifyStorefrontAPI(domain, token, GET_COLLECTIONS_QUERY, { first, cursor });
    return collectionsData.collections; // Return collections connection object (includes edges and pageInfo)
};

// New function to fetch products for preview (with pagination support)
export const fetchShopifyProductsList = async (domain, token, first = 10, cursor = null) => {
    const productsData = await fetchShopifyStorefrontAPI(domain, token, GET_PRODUCTS_QUERY, { first, cursor });
    return productsData.products; // Return products connection object
};

// New function to fetch localization info
export const fetchShopifyLocalizationInfo = async (domain, token, countryCode = "US", languageCode = "EN") => {
    // Note: The @inContext directive in GET_LOCALIZATION_INFO_QUERY might need to be dynamic
    // For now, it's hardcoded in the query. If dynamic context is needed, the query itself or variables would need adjustment.
    const localizationData = await fetchShopifyStorefrontAPI(domain, token, GET_LOCALIZATION_INFO_QUERY, {
      // Variables for @inContext if the query is parameterized.
      // Example: country: countryCode, language: languageCode 
    });
    return localizationData.localization;
};

// Modified to accept fetched data as parameters and a potential generated logo
export const mapShopifyDataToInternalStore = (shopifyStore, shopifyProducts, shopifyCollections, domain, { generateId = utilGenerateId } = {}, generatedLogoDataUrl = null) => {
    const mappedProducts = shopifyProducts.map(p => ({
      id: p.id, // Already a GID string
      name: p.title,
      // Use description from guide, not descriptionHtml
      description: p.description ? p.description.substring(0,250) + (p.description.length > 250 ? "..." : "") : 'No description available.',
      // Use priceV2 (aliased as price) from updated GET_PRODUCTS_QUERY
      price: parseFloat(p.variants?.edges[0]?.node.price?.amount || 0),
      currencyCode: p.variants?.edges[0]?.node.price?.currencyCode || 'USD',
      image: {
        id: p.images?.edges[0]?.node.id || generateId(),
        // Ensure URL is correctly accessed
        src: { medium: p.images?.edges[0]?.node.url || p.variants?.edges[0]?.node.image?.url || `https://via.placeholder.com/400x400.png?text=${encodeURIComponent(p.title)}` },
        alt: p.images?.edges[0]?.node.altText || p.variants?.edges[0]?.node.image?.altText || p.title,
      },
      tags: p.tags, // Tags is an array of strings
      availableForSale: p.variants?.edges[0]?.node.availableForSale,
      // Add other fields from GET_PRODUCTS_QUERY if needed for internal store
      rating: (Math.random() * 1.5 + 3.5).toFixed(1), 
      stock: Math.floor(Math.random() * 100) + 10, 
    }));

    // Map collections (basic mapping for now)
    const mappedCollections = shopifyCollections.map(c => ({
        id: c.id,
        title: c.title,
        description: c.description,
        handle: c.handle,
        // Potentially map products within collections if fetched and needed
        productCount: c.products?.edges?.length || 0, 
    }));
    
    // Use updated field names from GET_SHOP_METADATA_QUERY
    const primaryColor = shopifyStore.brand?.colors?.primary?.[0]?.background || getRandomColor();
    const heroImage = {
        id: generateId(),
        src: { large: shopifyStore.brand?.coverImage?.image?.url || `https://via.placeholder.com/1200x800.png?text=${encodeURIComponent(shopifyStore.name)}` },
        alt: shopifyStore.brand?.coverImage?.image?.altText || shopifyStore.name,
    };
    const shopifyProvidedLogo = shopifyStore.brand?.logo?.image?.url || shopifyStore.brand?.squareLogo?.image?.url;
    const logoUrl = generatedLogoDataUrl || shopifyProvidedLogo || `https://via.placeholder.com/100x100.png?text=${shopifyStore.name.substring(0,1)}`;
    const aiContent = generateAIStoreContent('general', shopifyStore.name); // Keep AI content for fallback

    return {
      id: `store-shopify-${shopifyStore.primaryDomain.host.replace(/\./g, '-')}-${generateId()}`,
      name: shopifyStore.name,
      type: 'shopify-imported',
      description: shopifyStore.description || shopifyStore.brand?.shortDescription || shopifyStore.brand?.slogan || aiContent.heroDescription,
      products: mappedProducts, // This is an existing JSONB column
      // collections: mappedCollections, // Removed from top level
      hero_image: heroImage,
      logo_url: logoUrl,
      theme: {
        primaryColor: primaryColor,
        secondaryColor: shopifyStore.brand?.colors?.secondary?.[0]?.background || getRandomColor(),
        fontFamily: getRandomFont(), 
        layout: getRandomLayout(),
      },
      content: {
          ...aiContent, // Keep base AI content
          heroTitle: `Welcome to ${shopifyStore.name}`,
          heroDescription: shopifyStore.description || shopifyStore.brand?.shortDescription || shopifyStore.brand?.slogan || aiContent.heroDescription,
          // Add other brand elements if available
          brandSlogan: shopifyStore.brand?.slogan,
          brandShortDescription: shopifyStore.brand?.shortDescription,
      },
      data_source: 'shopify'
      // The 'shopify_data' field containing domain, raw_metadata, and collections
      // is removed here to prevent Supabase errors if the column doesn't exist.
      // If this data needs to be persisted, a 'shopify_data' JSONB column
      // should be added to the 'stores' table in Supabase, and the commented-out
      // 'shopify_data' object below should be reinstated.
      // shopify_data: {
      //   domain: domain,
      //   raw_metadata: shopifyStore,
      //   collections: mappedCollections,
      // }
    };
};

// This function is now a wrapper that calls the mapping function.
// It will be called at the end of the wizard.
export const importShopifyStoreData = async (domain, token, shopifyStoreRaw, shopifyProductsRaw, shopifyCollectionsRaw, { generateId = utilGenerateId } = {}) => {
    // This function now assumes shopifyStoreRaw, shopifyProductsRaw, shopifyCollectionsRaw are already fetched and passed.
    // If they are not passed, it implies an error or a different flow.
    // For the wizard, these will be populated from previous steps.
    if (!shopifyStoreRaw || !shopifyProductsRaw || !shopifyCollectionsRaw) {
        // This case should ideally not be hit if the wizard flow is correct.
        // Fallback to old behavior if data isn't pre-fetched (though this path should be deprecated by wizard)
        console.warn("importShopifyStoreData called without pre-fetched data. Consider updating flow.");
        const tempShopData = await fetchShopifyStoreMetadata(domain, token);
        // Fetch all products and collections for simplicity in this fallback.
        // In a real scenario, you'd handle pagination properly here if this path was still active.
        const tempProductsData = await fetchShopifyProductsList(domain, token, 250); // Max items
        const tempCollectionsData = await fetchShopifyCollectionsList(domain, token, 50); // Max items

        return mapShopifyDataToInternalStore(
            tempShopData, 
            tempProductsData.edges.map(e => e.node), 
            tempCollectionsData.edges.map(e => e.node), 
            domain, 
            { generateId }
        );
    }

    return mapShopifyDataToInternalStore(
        shopifyStoreRaw, 
        shopifyProductsRaw, // Assuming this is an array of product nodes
        shopifyCollectionsRaw, // Assuming this is an array of collection nodes
        domain, 
        { generateId }
    );
};

// Placeholder for BigCommerce data mapping
export const mapBigCommerceDataToInternalStore = (bcStoreSettings, bcProducts, domain, { generateId = utilGenerateId } = {}, generatedLogoDataUrl = null) => {
  console.log("Mapping BigCommerce Data:", { bcStoreSettings, bcProducts, domain, generatedLogoDataUrl });

  const mappedProducts = bcProducts.map(p => ({
    id: p.entityId?.toString() || `bc-product-${generateId()}`, // Ensure ID is a string
    name: p.name || "Unnamed Product",
    description: p.description || `Product: ${p.name || "Unnamed Product"}`, // BC GraphQL might not provide full descriptions easily
    price: parseFloat(p.prices?.price?.value || 0),
    currencyCode: p.prices?.price?.currencyCode || 'USD',
    image: {
      id: `bc-img-${generateId()}`,
      src: { medium: p.defaultImage?.url || `https://via.placeholder.com/400x400.png?text=${encodeURIComponent(p.name || "Product")}` },
      alt: p.defaultImage?.altText || p.name || "Product Image",
    },
    sku: p.sku || '',
    // Add other fields from BigCommerce product data if needed
    rating: (Math.random() * 1.5 + 3.5).toFixed(1), 
    stock: Math.floor(Math.random() * 100) + 10, 
  }));

  const logoUrl = generatedLogoDataUrl || bcStoreSettings.logo?.image?.url || `https://via.placeholder.com/100x100.png?text=${(bcStoreSettings.storeName || "S").substring(0,1)}`;
  const aiContent = generateAIStoreContent('general', bcStoreSettings.storeName || "My BigCommerce Store");

  return {
    id: `store-bc-${(bcStoreSettings.storeHash || domain).replace(/[\.\/\:]/g, '-')}-${generateId()}`,
    name: bcStoreSettings.storeName || "My BigCommerce Store",
    type: 'bigcommerce-imported',
    description: bcStoreSettings.description || `Store imported from ${domain}` || aiContent.heroDescription,
    products: mappedProducts,
    hero_image: { 
        id: generateId(),
        src: { large: bcStoreSettings.logo?.image?.url || `https://via.placeholder.com/1200x800.png?text=${encodeURIComponent(bcStoreSettings.storeName || "Store")}` }, 
        alt: bcStoreSettings.logo?.image?.altText || bcStoreSettings.storeName || "Store Hero"
    },
    logo_url: logoUrl,
    theme: {
      primaryColor: getRandomColor(),
      secondaryColor: getRandomColor(),
      fontFamily: getRandomFont(),
      layout: getRandomLayout(),
    },
    content: {
        ...aiContent,
        heroTitle: `Welcome to ${bcStoreSettings.storeName || "Our Store"}`,
        heroDescription: bcStoreSettings.description || aiContent.heroDescription,
    },
    data_source: 'bigcommerce',
    // bigcommerce_data: { // Optional: store raw data if needed
    //   domain: domain,
    //   raw_settings: bcStoreSettings,
    // }
  };
};
